
<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>API Quiz</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f4f7f9; color: #333; }
    h1 { text-align: center; color: #2c3e50; }
    .quiz-container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
    .question { margin-bottom: 20px; }
    .question h3 { margin-bottom: 10px; }
    .options label { display: block; padding: 8px; background: #ecf0f1; margin-bottom: 5px; border-radius: 5px; cursor: pointer; }
    .options input { margin-right: 10px; }
    .btn { display: block; width: 100%; padding: 10px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; }
    .btn:hover { background: #2980b9; }
    .result { margin-top: 20px; padding: 15px; border-radius: 5px; display: none; }
    .correct { background: #2ecc71; color: white; }
    .incorrect { background: #e74c3c; color: white; }
    .explanation { font-size: 14px; color: #555; margin-top: 5px; }
  </style>
</head>
<body>
  <div class="quiz-container">
    <h1>API Quiz</h1>
    <form id="quizForm">
<div class="question"><h3>1. REST API'de idempotent olan HTTP metodu hangisidir?</h3><div class="options"><label><input type="radio" name="q1" value="a">a) POST</label><label><input type="radio" name="q1" value="b">b) PUT</label><label><input type="radio" name="q1" value="c">c) PATCH</label><label><input type="radio" name="q1" value="d">d) CONNECT</label></div><div class="explanation" id="exp1" style="display:none;"><strong>Doğru Cevap: b</strong> - PUT idempotenttir çünkü aynı isteği kaç kere gönderirsen gönder sistemin durumu değişmez.</div></div><div class="question"><h3>2. API testlerinde 'Contract Testing' neyi doğrular?</h3><div class="options"><label><input type="radio" name="q2" value="a">a) API performansını</label><label><input type="radio" name="q2" value="b">b) UI tutarlılığını</label><label><input type="radio" name="q2" value="c">c) Request/Response formatının beklendiği gibi olmasını</label><label><input type="radio" name="q2" value="d">d) Güvenlik açıklarını</label></div><div class="explanation" id="exp2" style="display:none;"><strong>Doğru Cevap: c</strong> - Contract Testing, API'nin Swagger/OpenAPI gibi şemalara uygun çalışıp çalışmadığını test eder.</div></div><div class="question"><h3>3. 401 Unauthorized hatası ne anlama gelir?</h3><div class="options"><label><input type="radio" name="q3" value="a">a) API bulunamadı</label><label><input type="radio" name="q3" value="b">b) Sunucu hatası</label><label><input type="radio" name="q3" value="c">c) Kullanıcının kimliği doğrulanmadı</label><label><input type="radio" name="q3" value="d">d) İstek zaman aşımına uğradı</label></div><div class="explanation" id="exp3" style="display:none;"><strong>Doğru Cevap: c</strong> - 401 hatası genellikle token veya kimlik doğrulama eksikliğinde döner.</div></div><div class="question"><h3>4. API rate limiting ne amaçla kullanılır?</h3><div class="options"><label><input type="radio" name="q4" value="a">a) Loglamayı azaltmak için</label><label><input type="radio" name="q4" value="b">b) Kullanıcı arayüzünü hızlandırmak için</label><label><input type="radio" name="q4" value="c">c) Sunucuya gelen istek sayısını sınırlamak için</label><label><input type="radio" name="q4" value="d">d) Cache kullanımını optimize etmek için</label></div><div class="explanation" id="exp4" style="display:none;"><strong>Doğru Cevap: c</strong> - Rate limiting, DDoS saldırılarını engellemek ve kaynakları korumak için istekleri sınırlar.</div></div><div class="question"><h3>5. GraphQL'in REST'e göre avantajı nedir?</h3><div class="options"><label><input type="radio" name="q5" value="a">a) Daha güvenlidir</label><label><input type="radio" name="q5" value="b">b) Gereksiz veri çekimini önler</label><label><input type="radio" name="q5" value="c">c) HTTP kullanmaz</label><label><input type="radio" name="q5" value="d">d) JSON desteklemez</label></div><div class="explanation" id="exp5" style="display:none;"><strong>Doğru Cevap: b</strong> - GraphQL, sadece ihtiyaç duyulan veriyi döndürür, over-fetching ve under-fetching sorunlarını çözer.</div></div><div class="question"><h3>6. Bir API testinde 'mock server' kullanmanın faydası nedir?</h3><div class="options"><label><input type="radio" name="q6" value="a">a) Performansı artırır</label><label><input type="radio" name="q6" value="b">b) Gerçek sunucuya ihtiyaç olmadan test yapmayı sağlar</label><label><input type="radio" name="q6" value="c">c) Kullanıcıya UI sağlar</label><label><input type="radio" name="q6" value="d">d) Sadece güvenlik için kullanılır</label></div><div class="explanation" id="exp6" style="display:none;"><strong>Doğru Cevap: b</strong> - Mock server, backend hazır olmadan test yapabilmeyi mümkün kılar.</div></div><div class="question"><h3>7. 429 Too Many Requests hatası neyi gösterir?</h3><div class="options"><label><input type="radio" name="q7" value="a">a) Yanlış endpoint</label><label><input type="radio" name="q7" value="b">b) Rate limit aşıldı</label><label><input type="radio" name="q7" value="c">c) Token süresi doldu</label><label><input type="radio" name="q7" value="d">d) Sunucu çökmesi</label></div><div class="explanation" id="exp7" style="display:none;"><strong>Doğru Cevap: b</strong> - 429 hatası genellikle API rate limit aşıldığında döner.</div></div><div class="question"><h3>8. API testinde 'Schema Validation' neden önemlidir?</h3><div class="options"><label><input type="radio" name="q8" value="a">a) UI tasarımını doğrular</label><label><input type="radio" name="q8" value="b">b) Response'un beklenen yapıda olduğunu kontrol eder</label><label><input type="radio" name="q8" value="c">c) Cache doğrulaması yapar</label><label><input type="radio" name="q8" value="d">d) Sadece hız testi yapar</label></div><div class="explanation" id="exp8" style="display:none;"><strong>Doğru Cevap: b</strong> - Schema validation, dönen JSON'un belirlenen şemaya uyup uymadığını kontrol eder.</div></div><div class="question"><h3>9. API güvenlik testinde en kritik konulardan biri nedir?</h3><div class="options"><label><input type="radio" name="q9" value="a">a) Token doğrulama</label><label><input type="radio" name="q9" value="b">b) UI responsiveness</label><label><input type="radio" name="q9" value="c">c) CSS hataları</label><label><input type="radio" name="q9" value="d">d) Mobil uyumluluk</label></div><div class="explanation" id="exp9" style="display:none;"><strong>Doğru Cevap: a</strong> - Güvenlik testlerinde access token doğrulama kritik öneme sahiptir.</div></div><div class="question"><h3>10. Negative API testi neden yapılır?</h3><div class="options"><label><input type="radio" name="q10" value="a">a) Hız ölçmek için</label><label><input type="radio" name="q10" value="b">b) Yanlış girişlerde API'nin hata döndürdüğünü görmek için</label><label><input type="radio" name="q10" value="c">c) UI testini desteklemek için</label><label><input type="radio" name="q10" value="d">d) Load testini güçlendirmek için</label></div><div class="explanation" id="exp10" style="display:none;"><strong>Doğru Cevap: b</strong> - Negative testler, API'nin hatalı isteklerde doğru hata kodu ve mesaj döndürmesini kontrol eder.</div></div><div class="question"><h3>11. API'nin 'stateless' olması ne anlama gelir?</h3><div class="options"><label><input type="radio" name="q11" value="a">a) API sürekli state tutar</label><label><input type="radio" name="q11" value="b">b) Her request bağımsızdır</label><label><input type="radio" name="q11" value="c">c) Client-side state yönetilir</label><label><input type="radio" name="q11" value="d">d) Sunucu cache kullanır</label></div><div class="explanation" id="exp11" style="display:none;"><strong>Doğru Cevap: b</strong> - Stateless API, her request’in bağımsız olduğu ve önceki isteğe bağlı olmadığı anlamına gelir.</div></div><div class="question"><h3>12. SOAP ile REST arasındaki temel fark nedir?</h3><div class="options"><label><input type="radio" name="q12" value="a">a) SOAP sadece XML kullanır, REST genellikle JSON kullanır</label><label><input type="radio" name="q12" value="b">b) REST daha yavaştır</label><label><input type="radio" name="q12" value="c">c) SOAP güvenliksizdir</label><label><input type="radio" name="q12" value="d">d) REST sadece POST destekler</label></div><div class="explanation" id="exp12" style="display:none;"><strong>Doğru Cevap: a</strong> - SOAP XML tabanlıdır, REST ise genellikle JSON ve hafif yapılar kullanır.</div></div><div class="question"><h3>13. API 'pagination' hangi durumda kullanılır?</h3><div class="options"><label><input type="radio" name="q13" value="a">a) Hataları yakalamak için</label><label><input type="radio" name="q13" value="b">b) Büyük veri setlerini parça parça almak için</label><label><input type="radio" name="q13" value="c">c) Güvenliği artırmak için</label><label><input type="radio" name="q13" value="d">d) Cache azaltmak için</label></div><div class="explanation" id="exp13" style="display:none;"><strong>Doğru Cevap: b</strong> - Pagination, çok büyük veri setlerini sayfalara bölerek performansı artırır.</div></div><div class="question"><h3>14. REST API'de PATCH ve PUT farkı nedir?</h3><div class="options"><label><input type="radio" name="q14" value="a">a) PUT kısmi güncelleme yapar, PATCH tüm nesneyi günceller</label><label><input type="radio" name="q14" value="b">b) PUT tüm nesneyi günceller, PATCH kısmi güncelleme yapar</label><label><input type="radio" name="q14" value="c">c) İkisi aynıdır</label><label><input type="radio" name="q14" value="d">d) Sadece POST yerine kullanılır</label></div><div class="explanation" id="exp14" style="display:none;"><strong>Doğru Cevap: b</strong> - PUT tüm kaynağı günceller, PATCH ise sadece belirli alanları değiştirir.</div></div><div class="question"><h3>15. API response time ölçmek için hangi test türü kullanılır?</h3><div class="options"><label><input type="radio" name="q15" value="a">a) Security testing</label><label><input type="radio" name="q15" value="b">b) Performance testing</label><label><input type="radio" name="q15" value="c">c) Unit testing</label><label><input type="radio" name="q15" value="d">d) Usability testing</label></div><div class="explanation" id="exp15" style="display:none;"><strong>Doğru Cevap: b</strong> - Performance testleri API'nin yanıt süresini ve yük altındaki davranışını ölçer.</div></div><div class="question"><h3>16. API'de cache-control header neden kullanılır?</h3><div class="options"><label><input type="radio" name="q16" value="a">a) Kimlik doğrulama için</label><label><input type="radio" name="q16" value="b">b) UI hızlandırmak için</label><label><input type="radio" name="q16" value="c">c) Response’un ne kadar süre cache’de tutulacağını belirtmek için</label><label><input type="radio" name="q16" value="d">d) Token üretmek için</label></div><div class="explanation" id="exp16" style="display:none;"><strong>Doğru Cevap: c</strong> - Cache-control, verinin tarayıcı veya proxy’de ne kadar saklanacağını belirler.</div></div><div class="question"><h3>17. API testlerinde environment neden kullanılır?</h3><div class="options"><label><input type="radio" name="q17" value="a">a) UI tasarımlarını değiştirmek için</label><label><input type="radio" name="q17" value="b">b) Farklı ortamlar için (dev, test, prod) base URL ve değişkenleri yönetmek için</label><label><input type="radio" name="q17" value="c">c) Response hızını artırmak için</label><label><input type="radio" name="q17" value="d">d) Güvenlik açıklarını kapatmak için</label></div><div class="explanation" id="exp17" style="display:none;"><strong>Doğru Cevap: b</strong> - Environment değişkenleri, testleri farklı ortamlarla kolayca çalıştırmayı sağlar.</div></div><div class="question"><h3>18. WebSocket API hangi amaçla kullanılır?</h3><div class="options"><label><input type="radio" name="q18" value="a">a) UI testlerini kolaylaştırmak için</label><label><input type="radio" name="q18" value="b">b) Gerçek zamanlı çift yönlü iletişim için</label><label><input type="radio" name="q18" value="c">c) Daha güvenli olduğu için</label><label><input type="radio" name="q18" value="d">d) Mobil uyumluluğu sağlamak için</label></div><div class="explanation" id="exp18" style="display:none;"><strong>Doğru Cevap: b</strong> - WebSocket, anlık mesajlaşma gibi senaryolarda çift yönlü iletişim sağlar.</div></div><div class="question"><h3>19. API monitoring ile ne amaçlanır?</h3><div class="options"><label><input type="radio" name="q19" value="a">a) API'nin uptime ve performansını sürekli takip etmek</label><label><input type="radio" name="q19" value="b">b) UI hatalarını görmek</label><label><input type="radio" name="q19" value="c">c) Rate limit kaldırmak</label><label><input type="radio" name="q19" value="d">d) Swagger dökümanı oluşturmak</label></div><div class="explanation" id="exp19" style="display:none;"><strong>Doğru Cevap: a</strong> - Monitoring, API'nin çalışırlığını ve performansını sürekli takip etmeye yarar.</div></div><div class="question"><h3>20. OAuth 2.0 Refresh Token ne işe yarar?</h3><div class="options"><label><input type="radio" name="q20" value="a">a) İlk login için kullanılır</label><label><input type="radio" name="q20" value="b">b) Access token süresi dolunca yeni access token almak için kullanılır</label><label><input type="radio" name="q20" value="c">c) Kullanıcıyı silmek için kullanılır</label><label><input type="radio" name="q20" value="d">d) Rate limit artırmak için kullanılır</label></div><div class="explanation" id="exp20" style="display:none;"><strong>Doğru Cevap: b</strong> - Refresh token, access token süresi dolduğunda kullanıcıdan tekrar login istemeden yeni token üretmek için kullanılır.</div></div>
      <button type="button" class="btn" onclick="checkAnswers()">Cevapları Gönder</button>
    </form>
    <div id="result" class="result"></div>
  </div>

  <script>
    function checkAnswers() {
      var correct = 0;
      var total = 20;
      for (var i = 1; i <= total; i++) {
        var q = document.querySelector('input[name="q'+i+'"]:checked');
        var exp = document.getElementById("exp"+i);
        if (q) {
          if (exp.innerHTML.includes("Doğru Cevap: " + q.value)) {
            correct++;
            exp.className = "explanation correct";
          } else {
            exp.className = "explanation incorrect";
          }
          exp.style.display = "block";
        }
      }
      var result = document.getElementById("result");
      result.style.display = "block";
      result.innerHTML = "✅ Doğru sayısı: " + correct + " / " + total;
      if (correct < total/2) {
        result.className = "result incorrect";
      } else {
        result.className = "result correct";
      }
    }
  </script>
</body>
</html>
